<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="../../../../xslt/source-code.xsl"?>
<classDetails className="net.sf.sanity4j.util.ExtractStats" pathToRoot="../../../../" qaVersion="1.1.1" runDate="Thu Aug 21 12:46:30 EST 2014">
<summary high="0" significant="0" moderate="0" low="1" info="3" lineCoverage="82" branchCoverage="56" quality="99"/>
<source>
<line>package net.sf.sanity4j.util;</line>
<line/>
<line>import java.io.File;</line>
<line>import java.io.FileInputStream;</line>
<line>import java.io.IOException;</line>
<line>import java.util.ArrayList;</line>
<line>import java.util.Date;</line>
<line>import java.util.HashMap;</line>
<line>import java.util.List;</line>
<line>import java.util.Map;</line>
<line>import java.util.Set;</line>
<line/>
<line>import net.sf.sanity4j.model.coverage.Coverage;</line>
<line>import net.sf.sanity4j.model.coverage.PackageCoverage;</line>
<line>import net.sf.sanity4j.model.diagnostic.Diagnostic;</line>
<line>import net.sf.sanity4j.model.diagnostic.DiagnosticSet;</line>
<line>import net.sf.sanity4j.model.summary.PackageSummary;</line>
<line>import net.sf.sanity4j.model.summary.SummaryCsvMarshaller;</line>
<line/>
<line>/**</line>
<line> * Utility class for extracting statistics from the various tool's XML outputs.</line>
<line> * Since many of the tools use different versions of paths (e.g. short</line>
<line> * file names on win32), the canonical path must be used when referring</line>
<line> * to any path.</line>
<line> *  </line>
<line> * @author Yiannis Paschalidis</line>
<line> * @since Sanity4J 1.0</line>
<line> */</line>
<line>public final class ExtractStats</line>
<line>{</line>
<line>    /** The directory containing the source code. */</line>
<line>    private final String sourceDirectory;</line>
<line/>
<line>    /** The set of diagnostics for the current run. */</line>
<line covered="yes">    private final DiagnosticSet diagnostics = new DiagnosticSet();</line>
<line/>
<line>    /** Top-level Unit test coverage. */</line>
<line covered="yes">    private final Coverage coverage = new Coverage();</line>
<line/>
<line>    /** Lines of code, by package name. */</line>
<line covered="yes">    private final Map&lt;String, Integer&gt; lineCountByPackage = new HashMap&lt;String, Integer&gt;();</line>
<line/>
<line>    /** Lines of code, by class name. */</line>
<line covered="yes">    private final Map&lt;String, Integer&gt; lineCountByClass = new HashMap&lt;String, Integer&gt;();</line>
<line/>
<line>    /** Number of classes per package, by package name. */</line>
<line covered="yes">    private final Map&lt;String, Integer&gt; classCountByPackage = new HashMap&lt;String, Integer&gt;();</line>
<line/>
<line>    /** Run summaries, by package name. */</line>
<line covered="yes">    private final Map&lt;String, List&lt;PackageSummary&gt;&gt; summaryByPackage = new HashMap&lt;String, List&lt;PackageSummary&gt;&gt;();</line>
<line/>
<line>    /** Summarised data for the current run. */</line>
<line>    private PackageSummary[] currentRunSummary;</line>
<line/>
<line>    /** A default size for a buffer. */</line>
<line>    private static final int BUF_SIZE = 4096;</line>
<line/>
<line>	/**</line>
<line>     * Creates an ExtractStats.</line>
<line>     * </line>
<line>     * @param sourceDirectory the source directory</line>
<line>     * @throws IOException if there is an error determining the canonical path of the source directory</line>
<line>     */</line>
<line>    public ExtractStats(final String sourceDirectory) throws IOException</line>
<line covered="yes">    {</line>
<line covered="yes">        this.sourceDirectory = getCanonicalPath(sourceDirectory);</line>
<line covered="yes">    }</line>
<line/>
<line>	/**</line>
<line>     * @return the source directory</line>
<line>     */</line>
<line>    public String getSourceDirectory()</line>
<line>    {</line>
<line covered="yes">        return sourceDirectory;</line>
<line>    }</line>
<line/>
<line>    /** @return the set of Diagnostics */</line>
<line>    public DiagnosticSet getDiagnostics()</line>
<line>    {</line>
<line covered="yes">        return diagnostics;</line>
<line>    }</line>
<line/>
<line>    /** @return the coverage */</line>
<line>    public Coverage getCoverage()</line>
<line>    {</line>
<line covered="yes">        return coverage;</line>
<line>    }</line>
<line/>
<line>	/**</line>
<line>	 * Extracts source file line counts for all source files .</line>
<line>     * @throws IOException if there is an error reading from a file</line>
<line>	 */</line>
<line>	public void extractLineCounts() throws IOException</line>
<line>	{</line>
<line covered="yes">	    extractLineCounts(new File(sourceDirectory));</line>
<line covered="yes">	}</line>
<line/>
<line>	/**</line>
<line>     * Extract source file line counts.</line>
<line>     * </line>
<line>     * @param file the file to count lines for</line>
<line>     * @throws IOException if there is an error reading from a file</line>
<line>     */</line>
<line>    private void extractLineCounts(final File file) throws IOException</line>
<line>    {</line>
<line covered="yes">        if (file.isDirectory())</line>
<line>        {</line>
<line covered="yes">            File[] children = file.listFiles();</line>
<line/>
<line covered="yes">            for (int i = 0; i &lt; children.length; i++)</line>
<line>            {</line>
<line covered="yes">                extractLineCounts(children[i]);</line>
<line>            }</line>
<line covered="yes">        }</line>
<line>        else</line>
<line>        {</line>
<line covered="yes">            int lineCount = countLines(file);</line>
<line covered="yes">            String path = file.getCanonicalPath();</line>
<line covered="yes">            String className = getClassNameForSourcePath(path);</line>
<line covered="yes">            String packageName = getPackageName(path);</line>
<line/>
<line covered="partial">            if (&quot;&quot;.equals(packageName))</line>
<line>            {</line>
<line covered="no">                packageName = &quot;default&quot;;</line>
<line>            }</line>
<line/>
<line covered="yes">            lineCountByClass.put(className, lineCount);</line>
<line/>
<line covered="yes">            Integer packageLineCount = lineCountByPackage.get(packageName);</line>
<line/>
<line covered="yes">            if (packageLineCount == null)</line>
<line>            {</line>
<line covered="yes">                lineCountByPackage.put(packageName, lineCount);</line>
<line>            }</line>
<line>            else</line>
<line>            {</line>
<line covered="yes">                packageLineCount = packageLineCount.intValue() + lineCount;</line>
<line covered="yes">                lineCountByPackage.put(packageName, packageLineCount);</line>
<line>            }</line>
<line/>
<line covered="yes">            Integer packageClassCount = classCountByPackage.get(packageName);</line>
<line/>
<line covered="yes">            if (packageClassCount == null)</line>
<line>            {</line>
<line covered="yes">                classCountByPackage.put(packageName, 1);</line>
<line>            }</line>
<line>            else</line>
<line>            {</line>
<line covered="yes">                packageClassCount = packageClassCount.intValue() + 1;</line>
<line covered="yes">                classCountByPackage.put(packageName, packageClassCount);</line>
<line>            }</line>
<line>        }</line>
<line covered="yes">    }</line>
<line/>
<line>	/**</line>
<line>     * Counts the number of lines in a file.</line>
<line>     * </line>
<line>     * @param file the text file to count lines for</line>
<line>     * @return the number of lines in the file</line>
<line>     * @throws IOException if there is an error reading from the file</line>
<line>     */</line>
<line>    private int countLines(final File file) throws IOException</line>
<line>    {</line>
<line covered="partial">        int count = file.length() == 0 ? 0 : 1;</line>
<line/>
<line covered="partial">        if (file.length() &gt; 0)</line>
<line>        {</line>
<line covered="no">            byte[] buf = new byte[BUF_SIZE];</line>
<line covered="no">            FileInputStream fis = null;</line>
<line/>
<line>            try</line>
<line>            {</line>
<line covered="no">                fis = new FileInputStream(file);</line>
<line/>
<line covered="no">                for (int len = fis.read(buf); len != -1; len = fis.read(buf))</line>
<line>                {</line>
<line covered="no">                    for (int i = 0; i &lt; len; i++)</line>
<line>                    {</line>
<line covered="no">                        if (buf[i] == '\n')</line>
<line>                        {</line>
<line covered="no">                            count++;</line>
<line>                        }</line>
<line>                    }</line>
<line>                }</line>
<line>            }</line>
<line>            finally</line>
<line>            {</line>
<line covered="no">                QaUtil.safeClose(fis);</line>
<line covered="no">            }</line>
<line>        }</line>
<line/>
<line covered="yes">        return count;</line>
<line>    }</line>
<line/>
<line>	/**</line>
<line>     * Returns the canonical (unique) version of the given path. See File.getCanonicalPath().</line>
<line>     * </line>
<line>     * @param path the path</line>
<line>     * @return the canonical version of the path</line>
<line>     * @throws IOException if there is a problem retrieving the path</line>
<line>     */</line>
<line>    public String getCanonicalPath(final String path) throws IOException</line>
<line>    {</line>
<line covered="yes">        File file = new File(path);</line>
<line/>
<line>        // May be relative to the source directory</line>
<line covered="yes">        if (!file.exists())</line>
<line>        {</line>
<line covered="yes">            File relativeFile = new File(sourceDirectory, path);</line>
<line/>
<line covered="partial">            if (relativeFile.exists())</line>
<line>            {</line>
<line covered="yes">                file = relativeFile;</line>
<line>            }</line>
<line>        }</line>
<line/>
<line>        // The file still may not exist, for example, generated classes,</line>
<line>        // with debugging info, where the source was deleted afterwards</line>
<line/>
<line covered="partial">        return file.exists() ? file.getCanonicalPath() : null;</line>
<line>    }</line>
<line/>
<line>	/**</line>
<line>     * Returns the class name for the given source path.</line>
<line>     * </line>
<line>     * @param sourcePath the source path</line>
<line>     * @return the class name, or &quot;unknown&quot; if not a class</line>
<line>     */</line>
<line>    public String getClassNameForSourcePath(final String sourcePath)</line>
<line>    {</line>
<line covered="yes">        String className = &quot;unknown&quot;;</line>
<line/>
<line covered="partial">        if (sourcePath != null &amp;&amp; sourcePath.toLowerCase().endsWith(&quot;.java&quot;))</line>
<line>        {</line>
<line covered="yes">            int basePathLength = getSourceDirectory().length() + 1;</line>
<line covered="yes">            String relativeSourcePath = sourcePath.substring(basePathLength);</line>
<line/>
<line>            // Strip off the file extension (if any)</line>
<line covered="yes">            int dotIndex = relativeSourcePath.lastIndexOf('.');</line>
<line covered="yes">            int lastPathIndex = relativeSourcePath.lastIndexOf(File.separatorChar);</line>
<line/>
<line covered="partial">            if (dotIndex &gt; lastPathIndex)</line>
<line>            {</line>
<line covered="yes">                relativeSourcePath = relativeSourcePath.substring(0, dotIndex);</line>
<line>            }</line>
<line/>
<line covered="yes">            className = relativeSourcePath.replace(File.separatorChar, '.');</line>
<line>        }</line>
<line/>
<line covered="yes">        return className;</line>
<line>    }</line>
<line/>
<line>	/**</line>
<line>     * Determines the &quot;correct&quot; package name for a java source file, given its </line>
<line>     * full path. The path is assumed to be inside getSourceDirectory() .</line>
<line>     * </line>
<line>     * @param sourceFilePath the full path to the source file</line>
<line>     * @return the package name for the given source file.</line>
<line>     */</line>
<line>    public String getPackageName(final String sourceFilePath)</line>
<line>    {</line>
<line>    	// Find the directory containing for the given sourceFilePath.</line>
<line covered="yes">    	String sourceDir = sourceFilePath;</line>
<line covered="yes">        File sourceFile = new File(sourceFilePath);</line>
<line/>
<line covered="partial">        if (!sourceFile.isDirectory())</line>
<line>        {</line>
<line covered="yes">            sourceDir = sourceFile.getParent();</line>
<line>        }</line>
<line/>
<line>        // If we are in the default package return &quot;&quot;;</line>
<line covered="yes">        int sourceDirectoryLength = getSourceDirectory().length() + 1;</line>
<line/>
<line covered="partial">        if (sourceDir.equals(getSourceDirectory()) || sourceDir.length() &lt; sourceDirectoryLength)</line>
<line>        {</line>
<line covered="no">            return &quot;&quot;;</line>
<line>        }</line>
<line/>
<line covered="yes">        String relativePath = sourceDir.substring(sourceDirectoryLength);</line>
<line covered="yes">        String packageName = relativePath.replace(File.separatorChar, '.');</line>
<line/>
<line covered="yes">        return packageName;</line>
<line>    }</line>
<line/>
<line>    /**</line>
<line>     * @return the total line count</line>
<line>     */</line>
<line>    public int getLineCount()</line>
<line>    {</line>
<line covered="yes">        int count = 0;</line>
<line/>
<line covered="yes">        for (Integer packageCount : lineCountByPackage.values())</line>
<line>        {</line>
<line covered="yes">            count += packageCount;</line>
<line>        }</line>
<line/>
<line covered="yes">        return count;</line>
<line>    }</line>
<line/>
<line>    /**</line>
<line>     * @return the total class count</line>
<line>     */</line>
<line>    public int getClassCount()</line>
<line>    {</line>
<line covered="yes">        int count = 0;</line>
<line/>
<line covered="yes">        for (Integer classCount : classCountByPackage.values())</line>
<line>        {</line>
<line covered="yes">            count += classCount;</line>
<line>        }</line>
<line/>
<line covered="yes">        return count;</line>
<line>    }</line>
<line/>
<line>	/**</line>
<line>     * Retrieves the line count for the given package.</line>
<line>     * </line>
<line>     * @param packageName the package name</line>
<line>     * @return the line count for the given package</line>
<line>     */</line>
<line>    public int getPackageLineCount(final String packageName)</line>
<line>    {</line>
<line covered="no">        Integer count = lineCountByPackage.get(packageName);</line>
<line covered="no">        return count == null ? 0 : count.intValue();</line>
<line>    }</line>
<line/>
<line>    /**</line>
<line>     * Retrieves the class count for the given package.</line>
<line>     * </line>
<line>     * @param packageName the package name</line>
<line>     * @return the class count for the given package</line>
<line>     */</line>
<line>    public int getPackageClassCount(final String packageName)</line>
<line>    {</line>
<line covered="yes">        Integer count = classCountByPackage.get(packageName);</line>
<line covered="partial">        return count == null ? 0 : count.intValue();</line>
<line>    }</line>
<line/>
<line>	/**</line>
<line>	 * Retrieves the line count for the given class.</line>
<line>	 * </line>
<line>	 * @param className the class name</line>
<line>	 * @return the line count for the given class</line>
<line>	 */</line>
<line>	public int getClassLineCount(final String className)</line>
<line>	{</line>
<line covered="no">	    Integer count = lineCountByClass.get(className);	    </line>
<line covered="no">	    return count == null ? 0 : count.intValue();</line>
<line>	}</line>
<line/>
<line>	/**</line>
<line>     * Reads the historical summary information.</line>
<line>     * </line>
<line>     * @param summaryFile the file to read from</line>
<line>     * @throws IOException if there is an error reading from the summary file </line>
<line>     */</line>
<line>	public void extractHistoricalSummary(final File summaryFile) throws IOException</line>
<line>	{</line>
<line>	    // Retrieve the summaries</line>
<line covered="no">	    SummaryCsvMarshaller marshaller = new SummaryCsvMarshaller();</line>
<line covered="no">	    PackageSummary[] summaries = marshaller.read(summaryFile);</line>
<line/>
<line>	    // Hash them by package name for efficiency</line>
<line covered="no">	    addSummariesToSummaryMap(summaries);</line>
<line covered="no">	}</line>
<line/>
<line>	/**</line>
<line>     * Retrieves the summary for the given package.</line>
<line>     * </line>
<line>     * @param packageName the package name</line>
<line>	 * @return a summary of the package quality over time, may be empty</line>
<line>	 */</line>
<line>	public PackageSummary[] getPackageSummary(final String packageName)</line>
<line>	{</line>
<line covered="no">	    if (currentRunSummary == null)</line>
<line>	    {</line>
<line covered="no">	        summariseCurrentRun();</line>
<line>	    }</line>
<line/>
<line covered="no">	    List&lt;PackageSummary&gt; summaries = summaryByPackage.get(packageName);</line>
<line/>
<line covered="no">	    if (summaries == null)</line>
<line>	    {</line>
<line covered="no">	        return new PackageSummary[0];</line>
<line>	    }</line>
<line>	    else</line>
<line>	    {</line>
<line covered="no">	        return summaries.toArray(new PackageSummary[summaries.size()]); </line>
<line>	    }</line>
<line>	}</line>
<line/>
<line>	/**</line>
<line>	 * @return a summary of the quality for this run</line>
<line>	 */</line>
<line>	public PackageSummary[] getRunSummary()</line>
<line>	{</line>
<line covered="partial">	    if (currentRunSummary == null)</line>
<line>	    {</line>
<line covered="yes">	        summariseCurrentRun();</line>
<line>	    }	</line>
<line/>
<line sev="1" covered="yes"><diag id="346"/><diag id="620"/>	    return currentRunSummary;</line>
<line>	}</line>
<line/>
<line>	/**</line>
<line>	 * Appends the current run into the package summary map.</line>
<line>	 */</line>
<line>	private void summariseCurrentRun()</line>
<line>	{</line>
<line covered="yes">        List&lt;PackageSummary&gt; entries = new ArrayList&lt;PackageSummary&gt;();</line>
<line covered="yes">        Set&lt;String&gt; packageNames = classCountByPackage.keySet();</line>
<line covered="yes">        Date currentDate = new Date();</line>
<line/>
<line>        // Summary for all packages</line>
<line covered="yes">	    PackageSummary rootEntry = new PackageSummary();</line>
<line covered="yes">	    rootEntry.setPackageName(&quot;&quot;);</line>
<line covered="yes">	    rootEntry.setRunDate(currentDate);</line>
<line covered="yes">	    rootEntry.setLineCoverage(coverage.getLineCoverage());</line>
<line covered="yes">	    rootEntry.setBranchCoverage(coverage.getBranchCoverage());</line>
<line covered="yes">	    rootEntry.setInfoCount(diagnostics.getCountForSeverity(Diagnostic.SEVERITY_INFO));</line>
<line covered="yes">        rootEntry.setLowCount(diagnostics.getCountForSeverity(Diagnostic.SEVERITY_LOW));</line>
<line covered="yes">        rootEntry.setModerateCount(diagnostics.getCountForSeverity(Diagnostic.SEVERITY_MODERATE));</line>
<line covered="yes">        rootEntry.setSignificantCount(diagnostics.getCountForSeverity(Diagnostic.SEVERITY_SIGNIFICANT));</line>
<line covered="yes">        rootEntry.setHighCount(diagnostics.getCountForSeverity(Diagnostic.SEVERITY_HIGH));</line>
<line covered="yes">        rootEntry.setLineCount(getLineCount());</line>
<line covered="yes">        entries.add(rootEntry);</line>
<line/>
<line>        // For each package</line>
<line covered="yes">    	for (String packageName : packageNames)</line>
<line>    	{</line>
<line sev="0" covered="yes"><diag id="621"/>    	    PackageSummary entry = new PackageSummary();</line>
<line covered="yes">            entry.setPackageName(packageName);</line>
<line covered="yes">    	    entry.setRunDate(currentDate);</line>
<line/>
<line covered="yes">            PackageCoverage packageCoverage = coverage.getPackageCoverage(packageName);</line>
<line/>
<line covered="partial">            if (packageCoverage != null)</line>
<line>            {</line>
<line covered="no">	            entry.setLineCoverage(packageCoverage.getLineCoverage());</line>
<line covered="no">	            entry.setBranchCoverage(packageCoverage.getBranchCoverage());</line>
<line>            }</line>
<line/>
<line>            // Diagnostics &amp; line-counts for this package and sub-packages</line>
<line covered="yes">            DiagnosticSet diagsForPackage = diagnostics.getDiagnosticsForPackage(packageName);</line>
<line covered="yes">            int lineCountForPackage = (lineCountByPackage.get(packageName)).intValue();</line>
<line covered="yes">            String packageNamePlusDot = packageName + '.';</line>
<line/>
<line covered="yes">            for (String otherPackageName : lineCountByPackage.keySet())</line>
<line>            {</line>
<line covered="yes">                if (otherPackageName.startsWith(packageNamePlusDot))</line>
<line>                {</line>
<line covered="yes">                    Integer lineCount = (lineCountByPackage.get(otherPackageName));</line>
<line covered="yes">                    lineCountForPackage += lineCount.intValue();</line>
<line covered="yes">                }</line>
<line>            }</line>
<line/>
<line covered="yes">            entry.setInfoCount(diagsForPackage.getCountForSeverity(Diagnostic.SEVERITY_INFO));</line>
<line covered="yes">            entry.setLowCount(diagsForPackage.getCountForSeverity(Diagnostic.SEVERITY_LOW));</line>
<line covered="yes">            entry.setModerateCount(diagsForPackage.getCountForSeverity(Diagnostic.SEVERITY_MODERATE));</line>
<line covered="yes">            entry.setSignificantCount(diagsForPackage.getCountForSeverity(Diagnostic.SEVERITY_SIGNIFICANT));</line>
<line covered="yes">            entry.setHighCount(diagsForPackage.getCountForSeverity(Diagnostic.SEVERITY_HIGH));</line>
<line covered="yes">            entry.setLineCount(lineCountForPackage);</line>
<line/>
<line covered="yes">            entries.add(entry);</line>
<line covered="yes">    	}        </line>
<line/>
<line covered="yes">    	currentRunSummary = entries.toArray(new PackageSummary[entries.size()]);</line>
<line/>
<line>    	// Now add them to the summary map</line>
<line covered="yes">    	addSummariesToSummaryMap(currentRunSummary);</line>
<line covered="yes">	}</line>
<line/>
<line>	/**</line>
<line>	 * Adds the given package summaries to the summary by package map.</line>
<line>	 * @param summaries the summaries to add</line>
<line>	 */</line>
<line>	private void addSummariesToSummaryMap(final PackageSummary[] summaries)</line>
<line>	{</line>
<line covered="yes">	    for (int i = 0; i &lt; summaries.length; i++)</line>
<line>	    {</line>
<line covered="yes">	        PackageSummary summary = summaries[i];</line>
<line covered="yes">	        List&lt;PackageSummary&gt; summariesForPackage = summaryByPackage.get(summary.getPackageName());</line>
<line/>
<line covered="partial">	        if (summariesForPackage == null)</line>
<line>	        {</line>
<line sev="0" covered="yes"><diag id="622"/>	            summariesForPackage = new ArrayList&lt;PackageSummary&gt;();</line>
<line covered="yes">	            summaryByPackage.put(summary.getPackageName(), summariesForPackage);	            </line>
<line>	        }</line>
<line/>
<line covered="yes">	        summariesForPackage.add(summary);</line>
<line>	    }	    </line>
<line covered="yes">	}	</line>
<line>}</line>
</source>
<diags first="false">
<diag id="346" sev="0" tool="Findbugs" rule="EI_EXPOSE_REP">net.sf.sanity4j.util.ExtractStats.getRunSummary() may expose internal representation by returning ExtractStats.currentRunSummary</diag>
<diag id="620" sev="1" tool="PMD" rule="MethodReturnsInternalArray">
Returning 'currentRunSummary' may expose an internal array.
</diag>
<diag id="621" sev="0" tool="PMD" rule="AvoidInstantiatingObjectsInLoops">
Avoid instantiating new objects inside loops
</diag>
<diag id="622" sev="0" tool="PMD" rule="AvoidInstantiatingObjectsInLoops">
Avoid instantiating new objects inside loops
</diag>
</diags>
</classDetails>
